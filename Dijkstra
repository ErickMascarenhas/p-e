#include <iostream>
#include <queue>
#include <vector>
#include <tuple>

#define infinito 1e9 // 1 * 10^9

using namespace std;

void dijkstra(vector<vector<tuple<double, int>>> &adj, int s){

    vector<double> dist(adj.size());
    vector<int> pre(adj.size());

    for (unsigned int i = 0; i < adj.size(); ++i){
        dist[i] = infinito;
        pre[i] = -1;
    }
    dist[s] = 0.0; // distancia de s ate a eh 0 (0.0 porque eh double)

    priority_queue<tuple<double, int>, vector<tuple<double, int>>, greater<tuple<double, int>>> H;

    H.push({0.0, s}); // coloca alguem na heap para o algoritmo funcionar

    while (!H.empty()){

        tuple<double, int> atual = H.top(); // pega o vertice do topo da heap
        H.pop();                            // remove o vertice da heap

        //separa os valores para facilitar o acesso depois
        double distancia = get<0>(atual);
        int vertice = get<1>(atual);

        if (distancia < dist[vertice])continue; // se ja achou um caminho menor, ignora

        for (tuple<double, int> vizinho : adj[vertice]){ // vai iterar sobre todos os vizinho dos vertice
            
            //separa os valores para facilitar o acesso depois
            double peso = get<0>(vizinho);
            int indice_v = get<1>(vizinho);
            
            if (dist[indice_v] > dist[vertice] + peso){
                dist[indice_v] = dist[vertice] + peso; // atualiza a distancia
                pre[indice_v] = vertice; // diz por onde veio ("quem eh pai daquele vertice")
                H.push({dist[indice_v], indice_v}); // coloca um novo elemento na heap já se preocupando com a prioridade
            }
        }
    }

    for (unsigned int i = 0; i < dist.size(); ++i) cout << "(" << i << " , " << dist[i] << ")" << endl;
    cout << endl; // printf("\n");
    for (unsigned int i = 0; i < pre.size(); ++i) cout << i << " filho de " << pre[i] << endl;
}

int main(int argc, char *argv[]){

    int n, m; // quantidade de vertices e arestas
    cin >> n >> m;

    vector<vector<tuple<double, int>>> adj(n); // criou um vetor de n vetores de tuplas inicialmente vazias
    //[[(), (), ()...],[(), (), ()...],[()...],[()...]...], na verdade as tuplas não existem, mas está reservado para tuplas

    int vertice, vizinho, peso;

    for (int i = 0; i < m; ++i){
        cin >> vertice >> vizinho >> peso;
        adj[vertice].push_back(make_tuple(peso, vizinho));
        adj[vizinho].push_back(make_tuple(peso, vertice));

        // botar o peso no meio que ai fica -> vertice - peso - vertice
    }

    //cin >> n; // vertice de comeco, temporario pois ele deve vir no -i senao coloca como 0
    dijkstra(adj, 7);

    return 0;
}
